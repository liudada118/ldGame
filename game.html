<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
    </style>
</head>

<body>
    <div id="webgl"></div>
    <script src="./static/js/three.js"></script>
    <script type='module'>
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
        
        import './static/js/GLTFLoader.js'
        
        import { util } from './static/js/util.js'

        let num = 0.1
        var MULTIPLIER = 1;
        var SLOW_MOTION = 0.1;
        var FAST_MOTION = 2;
        var mdir = 1;
        let activeAction, jumpAction, punchAction, mixer, clock, actions, start, model, cameraControls, moveX = 0, moveZ = 0
        let manPontorl = {
            up: false,
            down: false,
            left: false,
            right: false,
            punch: false,
            jump: false
        }
        let move = []
        const scene = new THREE.Scene()
        /**
         * 照相机
         * */
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000)
        var renderer = new THREE.WebGLRenderer()
        clock = new THREE.Clock();
        /**
         * 渲染背景
         * */
        renderer.setClearColor(0xffffff)
        renderer.setSize(window.innerWidth, window.innerHeight)
        var axes = new THREE.AxesHelper(20)
        // scene.add(axes)

        /**
         * 环境光
         * */
        const light = new THREE.AmbientLight(0xffffff); // soft white light
        scene.add(light);


        /**
         * 加载模型
         * */
        const loader = new THREE.GLTFLoader();
        loader.load('./static/model/RobotExpressive.glb', function (gltf) {

            model = gltf.scene;
            scene.add(model);
            const animations = gltf.animations
            mixer = new THREE.AnimationMixer(model)
            

            console.log(gltf)

            let skeleton = new THREE.SkeletonHelper(model);
            skeleton.visible = false;
            scene.add(skeleton);

            mixer.addEventListener('finished', function (e) {
                console.log(e)
                if (e.action._clip.name === 'Jump') {
                    console.log(111)
                    // jumpAction.enabled  = true 
                    console.log(jumpAction)
                }
            })
            actions = {}
            /**
             * 初始化动画
             * */
            for (let i = 0; i < animations.length; i++) {
                const clip = animations[i]
                const action = mixer.clipAction(clip)
                actions[clip.name] = action
                // action.clampWhenFinished = true;
                // action.loop = THREE.LoopOnce;
            }
            // activeAction = actions['Walking']
            // console.log(activeAction)
            // activeAction.play()

        }, undefined, function (e) {

            console.error(e);

        });

        const keyToAction = [
            {
                keyCodeArr: ['KeyW', 'ArrowUp'],
                actionName: 'up',
                actionState: manPontorl,
                aniName: 'up'
            },
            {
                keyCodeArr: ['KeyS', 'ArrowDown'],
                actionName: 'down',
                actionState: manPontorl,
                aniName: 'down'
            },
            {
                keyCodeArr: ['KeyA', 'ArrowLeft'],
                actionName: 'left',
                actionState: manPontorl,
                aniName: 'left'
            },
            {
                keyCodeArr: ['KeyD', 'ArrowRight'],
                actionName: 'right',
                actionState: manPontorl,
                aniName: 'right'
            },
            {
                keyCodeArr: ['KeyK'],
                actionName: 'punch',
                actionState: manPontorl,
                aniName: 'punch'
            },
            {
                keyCodeArr: ['Space'],
                actionName: 'jump',
                actionState: manPontorl,
                aniName: 'jump'
            },
        ]
        const directArr = ['up', 'down', 'left', 'right']
        /**
         * 绑定事件
         * */
        document.addEventListener("keydown", onDocumentKeyDown, false)
        document.addEventListener("keyup", onDocumentKeyUp, false)
        function onDocumentKeyDown(event) {

            keyToAction.forEach((a, index) => {

                util.bindAction(a.keyCodeArr, event.code, move, a.actionState, a.actionName, a.aniName)
            })



            if (move.some((a) => directArr.includes(a))) {
                activeAction = actions['Walking']
                activeAction.play()
                activeAction.weight = 1
            }

            if (move.includes('jump')) {

                jumpAction = actions['Jump']
                jumpAction.enabled = true
                jumpAction.loop = THREE.LoopRepeat
                jumpAction.play()
                // jumpAction.clampWhenFinished = true;
                // jumpAction.loop = THREE.LoopOnce;
            }

            if (move.includes('punch')) {
                console.log(222)
                punchAction = actions['Punch']
                punchAction.play()
                punchAction.clampWhenFinished = true;

                // punchAction.loop = THREE.LoopOnce ;

            }
            console.log(move)
        }
        function onDocumentKeyUp(event) {
            console.log(move)
            if (['KeyW', 'ArrowUp'].includes(event.code)) {
                manPontorl.up = false
                move.splice(move.indexOf('up'), 1)
                if (move.every((a) => !directArr.includes(a))) activeAction.stop();

            }

            if (['KeyS', 'ArrowDown'].includes(event.code)) {
                manPontorl.down = false
                move.splice(move.indexOf('down'), 1)
                if (move.every((a) => !directArr.includes(a))) activeAction.stop();

            }

            if (['KeyA', 'ArrowLeft'].includes(event.code)) {

                manPontorl.left = false
                move.splice(move.indexOf('left'), 1)
                if (move.every((a) => !directArr.includes(a))) activeAction.stop();

            }
            if (['KeyD', 'ArrowRight'].includes(event.code)) {

                manPontorl.right = false
                move.splice(move.indexOf('right'), 1)
                if (move.every((a) => !directArr.includes(a))) activeAction.stop();

            }

            if (['KeyK'].includes(event.code)) {

                manPontorl.punch = false
                move.splice(move.indexOf('KeyK'), 1)
                // punchAction.stop();
                // punchAction.loop = THREE.LoopRepeat

            }

            if (['Space'].includes(event.code)) {

                manPontorl.jump = false
                move.splice(move.indexOf('Space'), 1)
                // jumpAction.stop();

                // jumpAction.loop = THREE.LoopRepeat
            }


        }


        /**
        * 道路纹理贴图
        * */
        const textureLoader = new THREE.TextureLoader()
        // const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
        const roadTexture = textureLoader.load('./static/img/crate.gif')
        // roadTexture.anisotropy = maxAnisotropy;
        roadTexture.wrapS = roadTexture.wrapT = THREE.RepeatWrapping;
        roadTexture.repeat.set(100, 100);
        /**
         * 道路构建
         * */
        const roadGeometry = new THREE.PlaneGeometry(500, 500)
        const roadMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            map: roadTexture
        })
        const road = new THREE.Mesh(roadGeometry, roadMaterial)
        road.rotation.x = -Math.PI / 2
        scene.add(road)



        /**
         * 控制器
         * */

        // var delta = clock.getDelta();

        // MULTIPLIER = THREE.Math.clamp(MULTIPLIER + 0.5 * delta * mdir, SLOW_MOTION, 1);

        // delta *= MULTIPLIER;
        // const controls = new TrackballControls(camera, renderer.domElement);
        // // controls.target.set(0, 1, 0);
        // controls.dynamicDampingFactor = 0.25;

        // cameraControls = new OrbitControls(camera, renderer.domElement);
        // cameraControls.target.set(0, 50, 0);
        // cameraControls.update();


        camera.position.z = -10;
        camera.position.y = 3
        camera.position.x = 0
        camera.lookAt(0, 0, 0)

        document.getElementById("webgl").append(renderer.domElement)


        /**
         * 渲染
         * */
        function ani() {
            requestAnimationFrame(() => {
                ani()
                render()

                const dt = clock.getDelta();

                if (mixer) mixer.update(dt);
                if (manPontorl.up) {
                    activeAction.timeScale = 1
                    moveZ += 0.1 * Math.cos(model.rotation.y)
                    moveX += 0.1 * Math.sin(model.rotation.y)
                    model.position.z = moveZ
                    model.position.x = moveX
                }
                if (manPontorl.down) {
                    activeAction.timeScale = -1
                    moveZ -= 0.1 * Math.cos(model.rotation.y)
                    moveX -= 0.1 * Math.sin(model.rotation.y)
                    model.position.z = moveZ
                    model.position.x = moveX
                }
                if (manPontorl.left) {
                    moveZ -= 0.05 * Math.cos(model.rotation.y)
                    moveX -= 0.05 * Math.sin(model.rotation.y)
                    model.rotation.y += 0.05
                    model.position.z = moveZ
                    model.position.x = moveX
                }
                if (manPontorl.right) {
                    moveZ += 0.05 * Math.cos(model.rotation.y)
                    moveX += 0.05 * Math.sin(model.rotation.y)
                    model.rotation.y -= 0.05
                    model.position.z = moveZ
                    model.position.x = moveX
                }
            })
        }

        function render() {
            renderer.render(scene, camera);
            // controls.update(delta);
            camera.position.z = moveZ - 30;
            camera.position.y = !model ? 0 : model.position.y + 10
            camera.position.x = moveX + 0
        }
        ani()

        /**
         * 适配
         * */
        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }


    </script>
</body>

</html>