<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
    </style>
</head>

<body>
    <div id="webgl"></div>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/loaders/GLTFLoader.js"></script>
    <!-- <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script> -->
    <script type='module'>
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
        let num = 0.1
        var MULTIPLIER = 1;
        var SLOW_MOTION = 0.1;
        var FAST_MOTION = 2;
        var mdir = 1;
        let activeAction, mixer, clock, actions, start, model, cameraControls,moveX = 0,moveZ = 0
        let manPontorl = {
            up: false,
            down: false,
            left: false,
            right: false
        }
        let move = []
        const scene = new THREE.Scene()
        /**
         * 照相机
         * */
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000)
        var renderer = new THREE.WebGLRenderer()
        clock = new THREE.Clock();
        /**
         * 渲染背景
         * */
        renderer.setClearColor(0xffffff)
        renderer.setSize(window.innerWidth, window.innerHeight)
        var axes = new THREE.AxesHelper(20)
        // scene.add(axes)

        /**
         * 环境光
         * */
        const light = new THREE.AmbientLight(0xffffff); // soft white light
        scene.add(light);


        /**
         * 加载模型
         * */
        const loader = new THREE.GLTFLoader();
        loader.load('./static/model/RobotExpressive.glb', function (gltf) {

            model = gltf.scene;

            console.log(gltf.animations)
            scene.add(model);
            const animations = gltf.animations
            mixer = new THREE.AnimationMixer(model)
            console.log(mixer)

            actions = {}
            /**
             * 初始化动画
             * */
            for (let i = 0; i < animations.length; i++) {
                const clip = animations[i]
                const action = mixer.clipAction(clip)
                actions[clip.name] = action
                // action.clampWhenFinished = true;
                // action.loop = THREE.LoopOnce;
            }
            // activeAction = actions['Walking']
            // console.log(activeAction)
            // activeAction.play()

        }, undefined, function (e) {

            console.error(e);

        });

        /**
         * 绑定事件
         * */
        document.addEventListener("keydown", onDocumentKeyDown, false)
        document.addEventListener("keyup", onDocumentKeyUp, false)
        function onDocumentKeyDown(event) {
            console.log(event.code)
            if (['KeyW', 'ArrowUp'].includes(event.code)) {

                if (!manPontorl.up) {
                    activeAction = actions['Walking']
                    console.log('start')
                    activeAction.play()
                    move.push('up')
                }
                manPontorl.up = true;

            }

            if (['KeyS', 'ArrowDown'].includes(event.code)) {

                if (!manPontorl.down) {
                    activeAction = actions['Walking']
                    console.log('start')
                    activeAction.play()
                    move.push('down')
                }
                manPontorl.down = true;

            }

            if (['KeyA', 'ArrowLeft'].includes(event.code)) {

                if (!manPontorl.left) {
                    activeAction = actions['Walking']
                    console.log('start')
                    activeAction.play()
                    move.push('left')
                }
                manPontorl.left = true;

            }

            if (['KeyD', 'ArrowRight'].includes(event.code)) {

                if (!manPontorl.right) {
                    activeAction = actions['Walking']
                    console.log('start')
                    activeAction.play()
                    move.push('right')
                }
                manPontorl.right = true;

            }
        }
        function onDocumentKeyUp(event) {

            console.log(move)
            if (['KeyW', 'ArrowUp'].includes(event.code)) {
                manPontorl.up = false
                move.splice(move.indexOf('up'), 1)
                if (move.length == 0) activeAction.stop();

            }

            if (['KeyS', 'ArrowDown'].includes(event.code)) {
                manPontorl.down = false
                move.splice(move.indexOf('down'), 1)
                if (move.length == 0) activeAction.stop();

            }

            if (['KeyA', 'ArrowLeft'].includes(event.code)) {

                manPontorl.left = false
                move.splice(move.indexOf('left'), 1)
                if (move.length == 0) activeAction.stop();

            }
            if (['KeyD', 'ArrowRight'].includes(event.code)) {

                manPontorl.right = false
                move.splice(move.indexOf('right'), 1)
                if (move.length == 0) activeAction.stop();

            }
        }

        /**
        * 道路纹理贴图
        * */
        const textureLoader = new THREE.TextureLoader()
        // const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
        const roadTexture = textureLoader.load('./static/img/crate.gif')
        // roadTexture.anisotropy = maxAnisotropy;
        roadTexture.wrapS = roadTexture.wrapT = THREE.RepeatWrapping;
        roadTexture.repeat.set(100, 100);
        /**
         * 道路构建
         * */
        const roadGeometry = new THREE.PlaneGeometry(500, 500)
        const roadMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            map: roadTexture
        })
        const road = new THREE.Mesh(roadGeometry, roadMaterial)
        road.rotation.x = -Math.PI / 2
        scene.add(road)



        /**
         * 控制器
         * */

        // var delta = clock.getDelta();

        // MULTIPLIER = THREE.Math.clamp(MULTIPLIER + 0.5 * delta * mdir, SLOW_MOTION, 1);

        // delta *= MULTIPLIER;
        // const controls = new TrackballControls(camera, renderer.domElement);
        // // controls.target.set(0, 1, 0);
        // controls.dynamicDampingFactor = 0.25;

        // cameraControls = new OrbitControls(camera, renderer.domElement);
        // cameraControls.target.set(0, 50, 0);
        // cameraControls.update();


        camera.position.z = -10;
        camera.position.y = 3
        camera.position.x = 0
        camera.lookAt(0, 0, 0)

        document.getElementById("webgl").append(renderer.domElement)


        /**
         * 渲染
         * */
        function ani() {
            requestAnimationFrame(() => {
                ani()
                render()
                const dt = clock.getDelta();

                if (mixer) mixer.update(dt);
                if (manPontorl.up) {
                    
                    moveZ += 0.1 * Math.cos(model.rotation.y)
                    moveX += 0.1 * Math.sin(model.rotation.y)
                    model.position.z = moveZ
                    model.position.x = moveX
                }
                if (manPontorl.down) {
                    moveZ -= 0.1 * Math.cos(model.rotation.y)
                    moveX -= 0.1 * Math.sin(model.rotation.y)
                    model.position.z = moveZ
                    model.position.x = moveX
                }
                if (manPontorl.left) {
                    moveZ -= 0.05 * Math.cos(model.rotation.y)
                    moveX -= 0.05 * Math.sin(model.rotation.y)
                    model.rotation.y += 0.05
                    model.position.z = moveZ
                    model.position.x = moveX
                }
                if (manPontorl.right) {
                    moveZ += 0.05 * Math.cos(model.rotation.y)
                    moveX += 0.05 * Math.sin(model.rotation.y)
                    model.rotation.y -= 0.05
                    model.position.z = moveZ
                    model.position.x = moveX
                }
            })
        }

        function render() {
            renderer.render(scene, camera);
            // controls.update(delta);
            camera.position.z = moveZ - 30;
            camera.position.y = model.position.y + 10
            camera.position.x = moveX + 0
        }
        ani()

        /**
         * 适配
         * */
        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }


    </script>
</body>

</html>